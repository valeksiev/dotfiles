class CsvUpload 

  include Mongoid::Document
  include Mongoid::Timestamps::Short

  include Paperclip
  include Paperclip::Glue

  attr_accessor :code, :password_handler, :password_value

  field :status, type: String, default: ''
  field :processing_result, type: HashWithIndifferentAccess, default: {}

  belongs_to :school 

  HEADER_COLUMNS = %w( username password email first_name last_name )

  has_attached_file :file
  # Define the necessary collection fields in Mongoid for Paperclip
  field(:file_file_name,    :type => String)
  field(:file_content_type, :type => String)
  field(:file_file_size,    :type => Integer)
  field(:file_updated_at,   :type => DateTime)


  #serialize :processing_result

  validate :csv_format

  def generate_accounts
    accounts = {:success => [], :fail => []}
    CSV.foreach(file.path, :headers => true) do |csv_account|  
      csv_account = prepare_account csv_account.to_hash
      account = Account.new(csv_account)
      key = account.valid? ? :success : :fail
      accounts[key] << account.attributes.select { |attr| %w( first_name last_name password type email).include? attr }.merge(:errors => account.errors)
    end
    accounts
  end

  def prepare_account hash_account
    hash_account.merge(
        :password => handle_password(hash_account),
        :code => code,
        :in_school_id => school.id
      )
  end

  def handle_password hash_account
    case password_handler
    when 'specify'
      password_value
    when 'email', 'username'
      hash_account[password_handler]
    when 'generate'
      if hash_account['email']
        hash_account.merge!(:send_password_email => true)
        rand(2**256).to_s(36)[0..6] 
      else
        errors.add(:password, 'cannot generate password if email is not provided in the CSV file')
      end
    else
      hash_account['password']
    end
  end

  def csv_format
    file_path = file.queued_for_write[:original].path 
    begin
      unless CSV.read(file_path).first.sort == HEADER_COLUMNS.sort
        errors.add(:file, 'invalid_headers')
      end
    rescue Exception => e
      errors.add(:file, 'has invalid format') 
    end
  end

end
